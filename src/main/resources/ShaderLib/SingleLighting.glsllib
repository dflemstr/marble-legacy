
void SingleLighting_CalculateLightVector(const in vec3 worldPosition, const in vec4 lightPosition,
        const in vec4 lightColor, out vec3 lightVector, out float attenuation) {
    // positional or directional light?
    if (lightColor.w == 0.0) {
        lightVector = -lightPosition.xyz;
        attenuation = 1.0;
    } else {
        lightVector = lightPosition.xyz - worldPosition;
        float dist = length(lightVector);
        lightVector /= vec3(dist);
        attenuation = clamp(1.0 - lightPosition.w * dist, 0.0, 1.0);
    }  
}

void SingleLighting_AddLightPhong(const in vec3 n, const in vec3 l, const in vec3 i,
        const in vec3 lightColor, const in float attenuation, const in float shininess,
        inout vec3 diffuseLightSum, inout vec3 specularLightSum) {
    diffuseLightSum += lightColor * max(dot(l, n), 0.0) * attenuation;

    vec3 r = reflect(-l, n);
    specularLightSum += lightColor * pow(max(dot(r, i), 0.0), shininess) * attenuation;
}

void SingleLighting_AddLightOrenNayar(const in vec3 n, const in vec3 l, const in vec3 i,
        const in vec3 lightColor, const in float attenuation, const in float shininess,
        inout vec3 diffuseLightSum, inout vec3 specularLightSum) {
    float roughness = 1.0 / shininess;
    float r2 = roughness * roughness;
    float a = 1.0 - 0.5 * r2 / (r2 + 0.33);
    float idotn = dot(i, n);
    float ldotn = dot(l, n);
    float irradiance = max(0.0, ldotn);
    float angleDifference = max(0.0, dot(normalize(i - n * idotn), normalize(l - n * ldotn)));
    float alpha = min(idotn, ldotn);
    float beta  = max(idotn, ldotn);

    float bTerm;
    float b = 0.45 * r2 / (r2 + 0.09);
    bTerm = max(0.0, b * sqrt((1.0 - alpha * alpha) * (1.0 - beta * beta)) / beta * angleDifference);

    float diffuse = ldotn * (a + bTerm);
    diffuseLightSum  += lightColor * max(0.0, diffuse);
    specularLightSum += lightColor * max(0.0, diffuse);
}
